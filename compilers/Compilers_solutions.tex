\documentclass[12pt,a4paper,oneside,draft]{report}
\usepackage{ragged2e}
\usepackage{titlesec}
\usepackage{hyperref}
\usepackage{enumitem}
\usepackage{multicol}
\usepackage{amsmath}


\newcommand{\fakesection}[1]{% instead of /section
  \par\refstepcounter{section}% Increase section counter
  \sectionmark{#1}% Add section mark (header)
  \addcontentsline{toc}{section}{\protect\numberline{\thesection}#1}% Add section to ToC
  % Add more content here, if needed.
}

\overfullrule=0pt % black box fix

\def\Plus{\texttt{+}}
\def\Minus{\texttt{-}}
\def\aster{\textasteriskcentered{}}

\begin{document}

\titleformat{\chapter}[display] % Removing chapter header
{\normalfont\bfseries}{}{0pt}{\Large}

\begin{center}
	Solutions for Dragon Book
\end{center}

\chapter{}
\fakesection{}
\subsection{What is the difference between a compiler and an interpreter?}
Whereas compiler translates program with source langauge to a program with target language, 
interpreter on the other hand directly executes the operations specified in source program.

\subsection{What are the advantages of: (a) a compiler over an interpreter 
(b) an interpreter over a compiler?}
\begin{enumerate}[label=(\alph*)]
	\item Target program produced by a compiler is usually 
	much faster than an interpreter at mapping inputs to outputs.
	\item An interpreter can usually give better error diagnostics than a compiler, 
	because it executes source program statement by statement.
\end{enumerate}

\subsection{What advantages are there to a language processing system in compiler 
produces assembly language rather than machine language?}
Assembly language is easier to produce as output and easier to debug.

\subsection{A compiler that translates a high-level language into another high-level 
language is called a source-to-source translator. What advantages are there to 
using C as a target language for a compiler?}
C compilers are avaliable for any platform, which makes your 
language avaliable on any platform and architecture where C is avaliable. 
C compilers optimize agressively aswell.

\subsection{Describe some of the tasks that an assembler needs to perform.}
\begin{enumerate}
	\item Read input line from ASM file.
	\item Parse the opcode.
	\item Based on the opcode, ASM parser knows the next word. 
	At this point it has 8 bits which needs to be translated into the instruction.
	\item 8 bits is written to a binary file as two character hex number.
	\item Repeat from step one until all instructions are processed.
\end{enumerate}

\newpage

\fakesection{}\fakesection{}

\subsection{Indicate which of the following terms apply 
to which of the following languages:}
\begin{multicols}{3}
	\begin{enumerate}[label=\alph*)]
	\item imperative
	\item declarative
	\item von Neumann
	\item object-oriented
	\item functional
	\item third-generation
	\item fourth-generation
	\item scripting
	\item [\vspace{\fill}]
	\end{enumerate}
\end{multicols}

\begin{multicols}{5}
	\begin{enumerate}[label=\arabic*)]
		\item C
		\item C++
		\item Cobol
		\item Fortran
		\item Java
		\item Lisp
		\item ML
		\item Perl
		\item Python
		\item VB
	\end{enumerate}
\end{multicols}


\begin{itemize}
	\item[] Scripting: Python, Perl
	\item[] Declarative: ML
	\item[] Functional: ML
	\item[] Imperative: C, Java, Fortran
	\item[] Object-oriented: C++, Java, VB
	\item[] Von-Neumann: C, Fortran
	\item[] Third-generation: Fortran, Cobol, Lisp, C, C++, Java
\end{itemize}

\fakesection{}\fakesection{}\fakesection{}

\subsection{For the block-structured C code of Fig. 1.13(a), indicate the values assigned to w, x, y, and z.}
w = 13;	x = 11;	y = 13;	z = 11;
\subsection{Repeat Exercise 1.6.1 for the code of Fig. 1.13(b).}
w = 9; x = 7; y = 13; z = 11;

\newpage

\subsection{For the block-structured code of Fig. 1.14, assuming the usual static scoping of declarations, give the scope for each of the twelve declarations.}
\begin{multicols}{3}
	\begin{itemize}
		\item[] $w_1$: B1 — B3
		\item[] $x_1$: B1 — B2
		\item[] $y_1$: B1 — B5
		\item[] $z_1$: B1 — B2
		\item[] $x_2$: B2 — B3
		\item[] $z_2$: B2 — B3
		\item[] $w_3$: B3
		\item[] $x_3$: B3
		\item[] $w_4$: B4 — B5
		\item[] $x_4$: B4 — B5
		\item[] $y_5$: B5
		\item[] $z_5$: B5
	\end{itemize}
\end{multicols}

\subsection{What is printed by the following C code?}
3 2

\chapter{}
\fakesection{}\fakesection{}
\subsection{Consider the context-free grammar:}

\begin{center}
\item $S\; \rightarrow\; S\; S\; \textbf{\Plus}\; |\; S\;  S\; \textbf{\aster}\; |\; \textbf{a}$
\end{center}
\begin{enumerate}
\item[a)] Show how the string \textbf{aa\Plus a\aster} can be generated by this grammar.
\item[b)] Construct a tree for this string.
\item[c)] What language does this grammar generate? Justify your answer.
\end{enumerate}

\noindent (a)
\begin{enumerate}
\item[1.] $S\; \rightarrow\; S\; S\; \aster$
\item[2.] $S\; \rightarrow\; S\; S\; \Plus\; a\; \aster$
\item[3.] $S\; \rightarrow\; a\; a\; \Plus\; a\; \aster$ 
\end{enumerate}
(b)

\end{document}

